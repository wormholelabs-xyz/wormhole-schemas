use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=schemas");

    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("builtin_schemas.rs");

    let mut entries: Vec<(String, String)> = Vec::new();
    walk_schemas(Path::new("schemas"), &mut entries);
    entries.sort_by(|a, b| a.0.cmp(&b.0));

    let mut code = String::new();
    code.push_str(
        "/// Embedded schema definitions, generated by build.rs.\n\
         pub static BUILTIN_SCHEMAS: &[(&str, &str)] = &[\n",
    );
    for (key, rel_path) in &entries {
        // Use concat! + env! so include_str! resolves at compile time
        code.push_str(&format!(
            "    (\"{}\", include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/{}\"))),\n",
            key, rel_path
        ));
    }
    code.push_str("];\n");

    std::fs::write(&dest_path, code).unwrap();
}

/// Recursively walk the schemas directory and collect (key, relative_path) pairs.
///
/// Directory structure: `schemas/@org/repo/name.json` → key `@org/repo/name`
fn walk_schemas(dir: &Path, entries: &mut Vec<(String, String)>) {
    let Ok(read) = std::fs::read_dir(dir) else {
        return;
    };
    for entry in read.flatten() {
        let path = entry.path();
        if path.is_dir() {
            let name = path.file_name().unwrap().to_str().unwrap();
            if name.starts_with('@') {
                // @org directory — scan repo subdirectories
                walk_org(&path, entries);
            }
        } else if path.extension().and_then(|e| e.to_str()) == Some("json") {
            // Root-level schema (unlikely but supported)
            let stem = path.file_stem().unwrap().to_str().unwrap();
            entries.push((stem.to_string(), path.to_str().unwrap().to_string()));
        }
    }
}

fn walk_org(org_dir: &Path, entries: &mut Vec<(String, String)>) {
    let org = org_dir.file_name().unwrap().to_str().unwrap(); // "@org"
    let Ok(read) = std::fs::read_dir(org_dir) else {
        return;
    };
    for entry in read.flatten() {
        let repo_path = entry.path();
        if !repo_path.is_dir() {
            continue;
        }
        let repo = repo_path.file_name().unwrap().to_str().unwrap();
        let Ok(schemas) = std::fs::read_dir(&repo_path) else {
            continue;
        };
        for schema_entry in schemas.flatten() {
            let schema_path = schema_entry.path();
            if schema_path.extension().and_then(|e| e.to_str()) != Some("json") {
                continue;
            }
            let name = schema_path.file_stem().unwrap().to_str().unwrap();
            let key = format!("{}/{}/{}", org, repo, name);
            entries.push((key, schema_path.to_str().unwrap().to_string()));
        }
    }
}
